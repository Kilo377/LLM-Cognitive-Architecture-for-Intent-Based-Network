# 摘要

我们基于matlab 5G toolbox 搭建ORAN仿真平台.
具体来说, 场景中有一个RIC, 以及一个宏基站, 三个小区;
UE是移动的
## 基础场景开发
---
接下来是初步的代码架构, 但是这里需要考虑一下依赖路径的问题.
```
oran-sim/
│
├─ run/
│   ├─ run_experiment.m          % 主入口：选场景 + 选 xApp + 跑仿真
│   ├─ run_single_episode.m      % 单次 episode 执行
│   └─ default_config.m          % 全局默认参数
│
├─ core/                         % RAN 仿真内核（只做系统仿真）
│   ├─ ScenarioBuilder.m         % 宏站/小区/UE/业务/信道
│   ├─ MobilityModel.m           % UE 轨迹模型
│   ├─ TrafficModel.m            % 业务到达模型
│   ├─ ChannelModel.m            % 3GPP TDL/CDL 包装
│   ├─ RanKernel.m               % 推进 slot/TTI 的核心循环
│   ├─ RanStateBus.m             % RANState 结构定义
│   ├─ RanActionBus.m            % RANAction 结构定义
│   └─ Metrics.m                 % KPI 计算
│
├─ ric/
│   ├─ nearRT/
│   │   ├─ NearRTRIC.m           % near-RT RIC 主循环
│   │   ├─ ObsAdapter.m          % RANState → xApp Obs
│   │   ├─ ActionProjector.m     % xApp Action → 合法 RANAction
│   │   └─ NearRTConfig.m        % near-RT 参数模板
│   │
│   └─ nonRT/
│       ├─ NonRTRIC.m            % non-RT RIC 主循环
│       ├─ IntentManager.m       % 意图/目标管理（仿真版）
│       ├─ PolicyManager.m       % 策略与超参管理
│       ├─ Evaluator.m           % episode 级 KPI 评估
│       └─ NonRTConfig.m         % non-RT 参数模板
│
├─ xapps/                        % 每个 xApp 一个文件
│   ├─ xapp_template.m           % xApp 标准接口模板
│   ├─ xapp_mobility_lstm.m
│   ├─ xapp_energy_saver.m
│   ├─ xapp_spectrum_share.m
│   ├─ xapp_latency_scheduler.m
│   ├─ xapp_anomaly_detector.m
│   ├─ xapp_beamformer.m
│   └─ xapp_ul_power_control.m
│
├─ utils/
│   ├─ Logger.m                  % 统一日志
│   ├─ TimeManager.m             % 多时间尺度管理
│   ├─ ConstraintUtils.m         % 约束与投影工具
│   └─ PlotUtils.m               % 结果可视化
│
└─ README.md
```
最基本的框架已经开始搭建.

```
>> run_experiment
[ORAN-SIM] Path added: /Users/kilobao/Documents/MATLAB/Examples/R2025b/5g/5GORAN/oran-sim
[ORAN-SIM] Start episode
[Near-RT RIC] Initialized
[Non-RT RIC] Initialized
[Non-RT RIC] Tick
[Non-RT RIC] Tick
[ORAN-SIM] Episode finished
```
我建议先从场景搭建起, 未部署算法的场景也可以运行, 可以查看网络状态, 例如吞吐, 能耗, 等等KPI
1. 构建场景：1 宏 + 3 小区 + 10 UE + 移动轨迹 + 多业务
2. 运行系统级仿真：slot/TTI 推进
3. baseline 控制：默认调度、默认切换、默认功率、默认波束
4. 实时输出状态：每秒打印一次
5. 结束输出 KPI 报告：吞吐、时延分布、能耗、HO 统计、谱效
对于core文件夹的简单mvp已经跑通;
```
>> run_baseline_scenario
[ScenarioBuilder] Build scenario
[ScenarioBuilder] Scenario ready
[t=1.00s] thr=77.45 Mbps, energy=960.0 J, HO=3, URLLCdrop=93
[t=2.00s] thr=78.20 Mbps, energy=1920.0 J, HO=6, URLLCdrop=196

===== BASELINE REPORT =====
Total throughput: 78.20 Mbps
HO count: 6
Drops total: 288, URLLC: 196
Energy total: 1920.0 J
Energy efficiency: 8.146e+04 bit/J
PRB util per cell: 1.00 0.00 0.99 0.99 
```
但是这还没有加入5gtoolbox实现仿真, 接下来, 内部接入 5G Toolbox 的 NRCellPerformance / helperNR 真 PHY/MAC
新增`oran-sim/core/NrPhyMacAdapter.m`文件.\
根据建议, 该文件的目的是:
输入：\
-servingCell \
-UE SINR / CSI（或 RSRP + CQI）\
-PRB 分配 

输出：\
-实际成功传输 bit \
-BLER / HARQ 状态（可选）

已经完成了一个"可运行、PHY-aware、可扩展到 O-RAN 的系统级 5G RAN 仿真平台 baseline

---
## 20260209
接下来优先设计状态总线, 根据建议, 底层网络的信息将会反馈只`RanStateBus.m`,
由RIC, xApp读取.\
这样形成了一个分离层
```
RanStateBus
 ├─ time
 ├─ topology
 ├─ ue
 ├─ cell
 ├─ channel
 └─ kpi
```
在其中设计了一些层级结构:
1. 1️⃣ time 层, time 描述仿真进度。当前是第几个 slot, 当前时间是多少秒
2. 2️⃣ topology 层. topology 描述空间关系。基站位置\小区数量\UE 数量
3. 3️⃣ ue 层, ue 层是 xApp 用得最多的部分。它包含：UE 位置\UE 当前服务小区\UE 无线质量\UE 缓冲状态
4. 4️⃣ cell 层, cell 层描述每个小区的负载与运行状态。小区负载\PRB 利用率\能耗\睡眠状态
5. 5️⃣ channel 层, channel 层描述无线环境。
6. 6️⃣ kpi 层, kpi 层描述系统性能。
因此, 在真实 O-RAN 中：\\
RAN → E2 Node \\
RIC → 通过 E2SM 读状态 \\

在我们的仿真中：\\
RanKernel → RanStateBus \\
RIC / xApp → 直接读RanStateBus结构体 \\
RanStateBus 是 E2 接口的"算法级抽象"。

与该状态配套的是`ActionBus`
RanStateBus 是 观测。\\
RanActionBus 是 控制。\\

```
>> run_baseline_scenario
[RUN] ORAN-SIM baseline start
[ScenarioBuilder] Build scenario
[ScenarioBuilder] Scenario ready
[t=1.00s] thr=42.08 Mbps, energy=960.0 J, HO=3, URLLCdrop=94
[t=2.00s] thr=42.40 Mbps, energy=1920.0 J, HO=6, URLLCdrop=197

===== BASELINE REPORT =====
Total throughput: 42.40 Mbps
HO count: 6
Dropped packets: total=290, URLLC=197
Total energy: 1920.00 J
Energy efficiency: 4.416e+04 bit/J
PRB utilization per cell: 1.00 0.00 0.99 0.99 
[RUN] ORAN-SIM baseline finished
```
已经实现单步不做优化的baseline效果, 接下来目标是先完成持续模拟和可视化, 加入了
`visualization`目录. 至此, 基础场景部分开发已经实现.

## RIC
要开发RIC, 意味着要对gNB进行控制, 所以需要先开发`RanActionBus`,
在此之前, 对RIC进行进一步的设计:
non-RT负责生成rApp策略, 也就是rApp选xApp, near RT则部署xApp
一个简单的mvp是, non RT内部放了一个简易rApp policy, 选择了一个xApp, 
nearRT部署了这一xApp, 利用E2接口与网络交互. 

具体来说, non-RT根据输入来选择xApp, 目前留出输入接口, 但是在mvp时候, 我们可以订好rApp策略, 通过A1下发给near-RT, near-RT RIC 是 xApp 的运行容器
```
┌────────────────────────────┐
│         non-RT RIC         │
│                            │
│  ┌──────── rApp policy ───┐│
│  │  input → select xApp   ││
│  └────────────┬───────────┘│
│               │   (A1: policy semantics)
└───────────────┼────────────────────────┘
                │
┌───────────────▼────────────────────────┐
│          near-RT RIC                   │
│                                        │
│  active xApp container                 │
│                                        │
│  RanStateBus → xApp → RanActionBus     │
│              (E2 semantics)            │
└───────────────┼────────────────────────┘
                │
┌───────────────▼────────────────────────┐
│            RanKernelNR                 │
│                                        │
│  execute action / fallback baseline    │
│                                        │
└────────────────────────────────────────┘
```
### 关于time slot
non-time暂时不做时间,做触发式的, 有新输入就会生成新rApp policy, 
neartime要做时间, 因为xApp和下面层级的交互是有time slot的
```
slot:    |1|2|3|4|5|6|7|8|9|10|11|...
RAN:     step step step step step ...
near-RT:        tick         tick
xApp:           run          run
non-RT:   trigger only when new input arrives
```
因此根据建议, 在开发RIC之前, 必须先把时间设计做好. 
```
oran-sim/ric/nearRT/NearRTRIC.m
oran-sim/ric/nearRT/ObsAdapter.m
oran-sim/ric/nearRT/ActionGuard.m
```
现在 URLLC drop 非常高 改进空间巨大, 做 MAC Scheduler xApp,
该设计已经实在在专门的developlog, 尽管效果不好.
但是这证明当前框架已经跑通. 接下来我们首先把xApp效果调好的顺序向后放, 
先继续开发RIC

我希望框架的nearRT RIC支持 
1. 可以知道目前已经注册的xApps 
2. 可以控制单个xApp的启动或者关系 
3. 支持同时部署多个xApp, 尽管参数会打架

目前方案为设计注册表;
改进条目如下:
```
xAppSpec
 ├─ name                % string, 唯一标识
 ├─ objective           % string / short text
 ├─ domain              % enum / string
 ├─ fn                  % MATLAB function handle
 ├─ enabled             % bool（是否允许被启动）
 ├─ running             % bool（当前是否在运行）
 ├─ focusKPI            % string array
 ├─ controlParams       % string array
 ├─ description         % string（可选，但强烈建议）
```
为此, 接下来设计MATLAB xApp Registry 的最小实现示例结构
我们需要为xApp都设计一个format, 包含Registry的一些信息, 方便RIC直接读取, 然后一些状态信息则不需要放在xAPP里面, 我们要尽量降低xApp和RIC的耦合程度, 尽量设计新的xApp, 只要接口正确就可以被RIC直接识别, 并且装载或者关闭

明确目标后, 三个点需要实现:
1. 定时xApp Registry最小字段
2. 设计以后xApp都需要遵循的format, 之后修改我们的第一个xApp
3. 修改RIC可以做到灵活的兼容我们说到的概念  

每个 xApp 的最小结构:
```
xapp_xxx/
  ├─ registry.json
  └─ xapp_main.m
```
接下来, 为了实现RIC的自适应, 层次更改如下:
```
ric/
 ├─ nearRT/
 │   ├─ NearRTRIC.m          % 主控制器
 │   ├─ XAppManager.m       % 新增：xApp 生命周期
 │   ├─ XAppRegistry.m      % 新增：registry 解析与存储
 │   ├─ InputBuilder.m      % 新增：统一 input 构造
 │   ├─ ActionMerger.m      % 新增：多 xApp action 合并
 │   ├─ ActionGuard.m
 │   └─ ObsAdapter.m
 └─ nonRT/
     └─ NonRTRIC.m
```
先写XAppManager:
1. 维护 xApp 列表
2. 管理 xApp 开 / 关
3. 顺序调用 xApp
4. 收集每个 xApp 的 action

接下XActionMerger:
目标：只负责把多个 xApp 的 control 合成一个 control
把 XAppManager.run() 返回的 actions{} 合成一个 final_action。
暂时用这套:

actions 按顺序合并

只合并 action.control

字段冲突时用后者覆盖前者

元数据只做记录，不参与控制

空 action 直接跳过

当前, RIC的初步设计实现2个xApp的部署: 
1. URLLC 调度 → 控制 scheduling.selectedUE
2. Trajectory HO → 控制 handover.hysteresisOffset_dB

## 20260211
接下来暂时给near-RT的开了一个选择xApp集合的接口, 可以在`run_ric_mvp.m`里面
根据xApp的名字选择装在的xApp
```
xAppSet = [
        % "xapp_mac_scheduler_urllc_mvp"
        % "xapp_trajectory_handover"
        % "xapp_throughput_scheduler"
    ];
```

## 20260213
修复一个路径bug: 导致RIC检测不到xApp, 根目录下新增目录文件;

另, 发现UE小区切换的xApp性能几乎没有, 分析后发现主要问题来自
场景设计: UE移动速度太慢, 几乎不需要做切换, 因此优先修改UE移动模型:

改动 `UEMobilityModel.m` 文件

把当前"随机漂移模型"改成 Random Waypoint + 可分层速度 + 有边界。
1. 已经在可视化上看到用户移动, 但是是否装载xApp, 似乎没有任何影响;
2. 其次, Cell始终只有3个激活; 这是个疑点
第一个问题, 是`RanKernelNR.m`的逻辑写死, 因此改为可切换的方案

经过分析和改进, pipe可能是通的, 然而当前问题是: 
hysteresis不一定会影响任何一个KPI
问题在于性建模不够充分,


## 20260215 Core升级
经过当前分析, 场景存在以下问题:
1. 物理层建模不充分, 这影响了参数层的设计,
2. RanKernelNR太冗余了, 不好修改, 可能要再次拆解

因此, 接下来的步骤中, 更新NR是首要;

RanKernelNR 是一个"简化的系统级 NR 小区级仿真引擎", 负责
```
时间推进 + UE移动 + 信道测量 + HO判决 + 简化调度 + PHY抽象 + KPI统计
```

当前NR存在一些问题: 
1. 仿真程度不够真实. 我想要实现: xApp的部署, 并且分析它对网络的影响, 但是由于当前模型考虑不充分, 例如我想做HO的优化, 但是其控制参数既没有对网络KPI, 例如吞吐产生影响, 又没有代价模型. 当然, 我说的不仅是HO一个模型的问题, 我还想做beamforming, 能耗, 频谱优化, MAC调度, 业务等 
2. 这个NR代码写的非常长, 难以修改跟新, 我希望在保证当前逻辑与接口的情况下, 进一步对它进行解耦, 这样我方便后续的升级和修改 
3. 由于我对通信了解不深, 我希望解耦后的模型支持我频繁的升级与改动

## Core升级
改进NR需要对整个core进行重构
```
core/
│
├── kernel/
│   ├── RanKernelNR.m              % 外壳，只做slot管线调度
│   └── RanContext.m               % 运行时状态容器（新）
│
├── models/
│   ├── mobility/
│   │   └── UEMobilityModel.m
│   │
│   ├── traffic/
│   │   └── TrafficModel.m
│   │
│   ├── radio/
│   │   ├── RadioModel.m           % RSRP + SINR + beamforming
│   │   └── ChannelModel.m         % 可选，高保真升级位
│   │
│   ├── ho/
│   │   └── HandoverModel.m        % A3 + TTT + interruption
│   │
│   ├── scheduler/
│   │   ├── SchedulerBaseline.m
│   │   └── SchedulerActionAware.m
│   │
│   ├── phy/
│   │   └── NrPhyMacAdapter.m
│   │
│   ├── energy/
│   │   └── EnergyModel.m
│   │
│   └── kpi/
│       └── KpiTracker.m
│
├── bus/
│   ├── RanStateBus.m
│   └── RanActionBus.m
│
└── ScenarioBuilder.m
```
目前, 我们确定了
1. 解耦NR后可以跑通; 
2. 参数控制→KPI因果 链路已经打通, 


我们需要追求更真实的模型, 从而实现真实仿真; 根据因果关系, 我们逐一对models进行升级, 耦合性低, 自变量优先, 耦合性强的, 因变量放后, 例如energy, 其次, 我们增加UE侧的真实性

当前已经更新:
```
RanKernelNR
    |
    |-- ctx.nextSlot()
    |
    |-- MobilityModel
    |-- TrafficModel
    |-- RadioModel
    |-- HandoverModel
    |-- SchedulerPRBModel
    |-- PhyServiceModel
    |-- EnergyModelBS
    |-- KPIModel
    |
    |-- StateModel -> RanStateBus
```

现有控制域

scheduling

power

sleep

handover

beam

radio：频谱/带宽控制

energy：能耗策略控制（如动态 P0 scaling）

qos：调度权重控制

rlf：RLF 参数控制

beam：升级为可扩展结构

## 20260217 RIC升级
`ActionMerger.m`负责把多个 xApp 的决策结果合并成一个统一的 RAN 动作结构，供 Near-RT RIC 下发到网络侧执行。

已经根据Core的跟新修改RIC, xApp已经可以影响RAN, 接下来应该研究xApp Conflict
现在的 ActionMerger 是：
```
后面的 xApp 覆盖前面的
```

当前RIC的pipe:
```
RanStateBus
   ↓
ObsAdapter: 把 RanStateBus 转换成 xApp 可用的轻量观测结构：
   ↓
InputBuilder: 统一 xApp 输入格式
   ↓
XAppManager.run: 激活选择的xApp
   ↓
ActionMerger: 动作整合
   ↓
ActionGuard: 检查输出合法性
   ↓
RanActionBus.validate
   ↓
Kernel / gNB
```
这是在Core更新前的, `ObsAdapter.m`, 缺少观测变量; 更新后:
 
🔎 现在 Obs 包含的全部可观测域
```
obs.time
obs.topology
obs.ue
obs.cell
obs.radio
obs.channel
obs.events
obs.kpi
obs.meta
obs.ext
```
这是一个完整 near-RT 观测接口。这些是给xApp看的必要参数;

回到设计中:

这些参数分为两部分用:

xApp设计: 需要知道可观测参数RanState, 选择控制参数RanAction, 并且补充期望影响的kpi, 并且写在registry.json方便遍历

xApp选择(图推理算法): 需要知道有哪些xApp, 他们的控制参数, 以及影响的kpi ← 这些应该是从xApp这里得到的.

目前的仿真架构, 控制参数有; xApp注册与规范有; 但是KPI做的还不是很全面
所以优先更新一下kpi,
随后简单做一个冲突冗余模块, 设计一下baseline, 
就可以做图推理了,
 
计划是跟新core/kpi:

新增的 KPI 维度
```
类别	         新 KPI
Capacity	throughput_avg_bps
Capacity	throughput_edge5_bps
Energy	        energy_eff_bit_per_J
Resource	prbUtil_avg
Mobility	hoRate_per_s
Reliability	dropRatio
Fairness	jainFairness
```

写一个run的程序, 
分别控制目前所有的控制参数, 并且分析每一个对于当前网络所有kpi的影响, 从而可以设计一个表格

更新为run_control_sensitivity_v2。它会额外打印：

mean SINR

mean MCS

mean BLER

dropRatio

但是当前的run是不合理的, 网络的kpi应该在网络层打印, 
run只是调取. 接下来, 我们还是应该修改网络本身, 并且
增强kpi/

✅ KPIModel v3（完整网络KPI版本）


RanContext 新字段

PhyServiceModel 修改点

Scheduler 修改点

KPIModel 完整代码

finalize 修改版

精简 run

更新计划为:
core/

1. core/RanContext.m（新增 KPI 累加器与基线字段）

2. core/RanKernelNR.m（加入 ActionApplier，补齐 KPI 流水线，finalize 走 KPIModel）

3. core/kpi/KPIModel.m（升级为 KPIModel v3，全网 KPI 统一在这里算）

models/

4) models/ActionApplierModel.m（修正 basePRB 的存放位置，避免每 slot 丢失）
5) models/PhyServiceModel.m（累加 MCS/BLER/TB 计数，修正 lastPRBUsedPerCell 的缺口）
6) models/SchedulerPRBModel.m（睡眠门控，写入每 slot 的调度统计）
7) models/EnergyModelBS.m（读取 basePowerScale，读取 sleep，读取事件能耗）

现存的 SchedulerModel.m是上一个版本了，建议不要再用它。只用 SchedulerPRBModel()。