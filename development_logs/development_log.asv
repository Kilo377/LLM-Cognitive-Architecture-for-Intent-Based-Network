# 摘要

我们基于matlab 5G toolbox 搭建ORAN仿真平台.
具体来说, 场景中有一个RIC, 以及一个宏基站, 三个小区;
UE是移动的
## 基础场景开发
---
接下来是初步的代码架构, 但是这里需要考虑一下依赖路径的问题.
```
oran-sim/
│
├─ run/
│   ├─ run_experiment.m          % 主入口：选场景 + 选 xApp + 跑仿真
│   ├─ run_single_episode.m      % 单次 episode 执行
│   └─ default_config.m          % 全局默认参数
│
├─ core/                         % RAN 仿真内核（只做系统仿真）
│   ├─ ScenarioBuilder.m         % 宏站/小区/UE/业务/信道
│   ├─ MobilityModel.m           % UE 轨迹模型
│   ├─ TrafficModel.m            % 业务到达模型
│   ├─ ChannelModel.m            % 3GPP TDL/CDL 包装
│   ├─ RanKernel.m               % 推进 slot/TTI 的核心循环
│   ├─ RanStateBus.m             % RANState 结构定义
│   ├─ RanActionBus.m            % RANAction 结构定义
│   └─ Metrics.m                 % KPI 计算
│
├─ ric/
│   ├─ nearRT/
│   │   ├─ NearRTRIC.m           % near-RT RIC 主循环
│   │   ├─ ObsAdapter.m          % RANState → xApp Obs
│   │   ├─ ActionProjector.m     % xApp Action → 合法 RANAction
│   │   └─ NearRTConfig.m        % near-RT 参数模板
│   │
│   └─ nonRT/
│       ├─ NonRTRIC.m            % non-RT RIC 主循环
│       ├─ IntentManager.m       % 意图/目标管理（仿真版）
│       ├─ PolicyManager.m       % 策略与超参管理
│       ├─ Evaluator.m           % episode 级 KPI 评估
│       └─ NonRTConfig.m         % non-RT 参数模板
│
├─ xapps/                        % 每个 xApp 一个文件
│   ├─ xapp_template.m           % xApp 标准接口模板
│   ├─ xapp_mobility_lstm.m
│   ├─ xapp_energy_saver.m
│   ├─ xapp_spectrum_share.m
│   ├─ xapp_latency_scheduler.m
│   ├─ xapp_anomaly_detector.m
│   ├─ xapp_beamformer.m
│   └─ xapp_ul_power_control.m
│
├─ utils/
│   ├─ Logger.m                  % 统一日志
│   ├─ TimeManager.m             % 多时间尺度管理
│   ├─ ConstraintUtils.m         % 约束与投影工具
│   └─ PlotUtils.m               % 结果可视化
│
└─ README.md
```
最基本的框架已经开始搭建.

```
>> run_experiment
[ORAN-SIM] Path added: /Users/kilobao/Documents/MATLAB/Examples/R2025b/5g/5GORAN/oran-sim
[ORAN-SIM] Start episode
[Near-RT RIC] Initialized
[Non-RT RIC] Initialized
[Non-RT RIC] Tick
[Non-RT RIC] Tick
[ORAN-SIM] Episode finished
```
我建议先从场景搭建起, 未部署算法的场景也可以运行, 可以查看网络状态, 例如吞吐, 能耗, 等等KPI
1. 构建场景：1 宏 + 3 小区 + 10 UE + 移动轨迹 + 多业务
2. 运行系统级仿真：slot/TTI 推进
3. baseline 控制：默认调度、默认切换、默认功率、默认波束
4. 实时输出状态：每秒打印一次
5. 结束输出 KPI 报告：吞吐、时延分布、能耗、HO 统计、谱效
对于core文件夹的简单mvp已经跑通;
```
>> run_baseline_scenario
[ScenarioBuilder] Build scenario
[ScenarioBuilder] Scenario ready
[t=1.00s] thr=77.45 Mbps, energy=960.0 J, HO=3, URLLCdrop=93
[t=2.00s] thr=78.20 Mbps, energy=1920.0 J, HO=6, URLLCdrop=196

===== BASELINE REPORT =====
Total throughput: 78.20 Mbps
HO count: 6
Drops total: 288, URLLC: 196
Energy total: 1920.0 J
Energy efficiency: 8.146e+04 bit/J
PRB util per cell: 1.00 0.00 0.99 0.99 
```
但是这还没有加入5gtoolbox实现仿真, 接下来, 内部接入 5G Toolbox 的 NRCellPerformance / helperNR 真 PHY/MAC
新增`oran-sim/core/NrPhyMacAdapter.m`文件.\
根据建议, 该文件的目的是:
输入：\
-servingCell \
-UE SINR / CSI（或 RSRP + CQI）\
-PRB 分配 

输出：\
-实际成功传输 bit \
-BLER / HARQ 状态（可选）

已经完成了一个"可运行、PHY-aware、可扩展到 O-RAN 的系统级 5G RAN 仿真平台 baseline

---
## 20260209Z
接下来优先设计状态总线, 根据建议, 底层网络的信息将会反馈只`RanStateBus.m`,
由RIC, xApp读取.\
这样形成了一个分离层
```
RanStateBus
 ├─ time
 ├─ topology
 ├─ ue
 ├─ cell
 ├─ channel
 └─ kpi
```
在其中设计了一些层级结构:
1. 1️⃣ time 层, time 描述仿真进度。当前是第几个 slot, 当前时间是多少秒
2. 2️⃣ topology 层. topology 描述空间关系。基站位置\小区数量\UE 数量
3. 3️⃣ ue 层, ue 层是 xApp 用得最多的部分。它包含：UE 位置\UE 当前服务小区\UE 无线质量\UE 缓冲状态
4. 4️⃣ cell 层, cell 层描述每个小区的负载与运行状态。小区负载\PRB 利用率\能耗\睡眠状态
5. 5️⃣ channel 层, channel 层描述无线环境。
6. 6️⃣ kpi 层, kpi 层描述系统性能。
因此, 在真实 O-RAN 中：\\
RAN → E2 Node \\
RIC → 通过 E2SM 读状态 \\

在我们的仿真中：\\
RanKernel → RanStateBus \\
RIC / xApp → 直接读RanStateBus结构体 \\
RanStateBus 是 E2 接口的"算法级抽象"。

与该状态配套的是`ActionBus`
RanStateBus 是 观测。\\
RanActionBus 是 控制。\\

```
>> run_baseline_scenario
[RUN] ORAN-SIM baseline start
[ScenarioBuilder] Build scenario
[ScenarioBuilder] Scenario ready
[t=1.00s] thr=42.08 Mbps, energy=960.0 J, HO=3, URLLCdrop=94
[t=2.00s] thr=42.40 Mbps, energy=1920.0 J, HO=6, URLLCdrop=197

===== BASELINE REPORT =====
Total throughput: 42.40 Mbps
HO count: 6
Dropped packets: total=290, URLLC=197
Total energy: 1920.00 J
Energy efficiency: 4.416e+04 bit/J
PRB utilization per cell: 1.00 0.00 0.99 0.99 
[RUN] ORAN-SIM baseline finished
```
已经实现单步不做优化的baseline效果, 接下来目标是先完成持续模拟和可视化, 加入了
`visualization`目录. 至此, 基础场景部分开发已经实现.

## RIC
要开发RIC, 意味着要对gNB进行控制, 所以需要先开发`RanActionBus`,
在此之前, 对RIC进行进一步的设计:
non-RT负责生成rApp策略, 也就是rApp选xApp, near RT则部署xApp
一个简单的mvp是, non RT内部放了一个简易rApp policy, 选择了一个xApp, 
nearRT部署了这一xApp, 利用E2接口与网络交互. 

具体来说, non-RT根据输入来选择xApp, 目前留出输入接口, 但是在mvp时候, 我们可以订好rApp策略, 通过A1下发给near-RT, near-RT RIC 是 xApp 的运行容器
```
┌────────────────────────────┐
│         non-RT RIC         │
│                            │
│  ┌──────── rApp policy ───┐│
│  │  input → select xApp   ││
│  └────────────┬───────────┘│
│               │   (A1: policy semantics)
└───────────────┼────────────────────────┘
                │
┌───────────────▼────────────────────────┐
│          near-RT RIC                   │
│                                        │
│  active xApp container                 │
│                                        │
│  RanStateBus → xApp → RanActionBus     │
│              (E2 semantics)            │
└───────────────┼────────────────────────┘
                │
┌───────────────▼────────────────────────┐
│            RanKernelNR                 │
│                                        │
│  execute action / fallback baseline    │
│                                        │
└────────────────────────────────────────┘
```
### 关于time slot
non-time暂时不做时间,做触发式的, 有新输入就会生成新rApp policy, 
neartime要做时间, 因为xApp和下面层级的交互是有time slot的
```
slot:    |1|2|3|4|5|6|7|8|9|10|11|...
RAN:     step step step step step ...
near-RT:        tick         tick
xApp:           run          run
non-RT:   trigger only when new input arrives
```
因此根据建议, 在开发RIC之前, 必须先把时间设计做好. 
```
oran-sim/ric/nearRT/NearRTRIC.m
oran-sim/ric/nearRT/ObsAdapter.m
oran-sim/ric/nearRT/ActionGuard.m
```
现在 URLLC drop 非常高 改进空间巨大, 做 MAC Scheduler xApp,
该设计已经实在在专门的developlog, 尽管效果不好.
但是这证明当前框架已经跑通. 接下来我们首先把xApp效果调好的顺序向后放, 
先继续开发RIC

我希望框架的nearRT RIC支持 
1. 可以知道目前已经注册的xApps 
2. 可以控制单个xApp的启动或者关系 
3. 支持同时部署多个xApp, 尽管参数会打架

目前方案为设计注册表;
改进条目如下:
```
xAppSpec
 ├─ name                % string, 唯一标识
 ├─ objective           % string / short text
 ├─ domain              % enum / string
 ├─ fn                  % MATLAB function handle
 ├─ enabled             % bool（是否允许被启动）
 ├─ running             % bool（当前是否在运行）
 ├─ focusKPI            % string array
 ├─ controlParams       % string array
 ├─ description         % string（可选，但强烈建议）
```
为此, 接下来设计MATLAB xApp Registry 的最小实现示例结构
我们需要为xApp都设计一个format, 包含Registry的一些信息, 方便RIC直接读取, 然后一些状态信息则不需要放在xAPP里面, 我们要尽量降低xApp和RIC的耦合程度, 尽量设计新的xApp, 只要接口正确就可以被RIC直接识别, 并且装载或者关闭

明确目标后, 三个点需要实现:
1. 定时xApp Registry最小字段
2. 设计以后xApp都需要遵循的format, 之后修改我们的第一个xApp
3. 修改RIC可以做到灵活的兼容我们说到的概念  

每个 xApp 的最小结构:
```
xapp_xxx/
  ├─ registry.json
  └─ xapp_main.m
```
接下来, 为了实现RIC的自适应, 层次更改如下:
```
ric/
 ├─ nearRT/
 │   ├─ NearRTRIC.m          % 主控制器
 │   ├─ XAppManager.m       % 新增：xApp 生命周期
 │   ├─ XAppRegistry.m      % 新增：registry 解析与存储
 │   ├─ InputBuilder.m      % 新增：统一 input 构造
 │   ├─ ActionMerger.m      % 新增：多 xApp action 合并
 │   ├─ ActionGuard.m
 │   └─ ObsAdapter.m
 └─ nonRT/
     └─ NonRTRIC.m
```
先写XAppManager:
1. 维护 xApp 列表
2. 管理 xApp 开 / 关
3. 顺序调用 xApp
4. 收集每个 xApp 的 action
接下XActionMerger:
目标：把 XAppManager.run() 返回的 actions{} 合成一个 final_action。
暂时用这套:

actions 按顺序合并

只合并 action.control

字段冲突时用后者覆盖前者

元数据只做记录，不参与控制

空 action 直接跳过

当前, RIC的初步设计实现2个xApp的部署.
来引入第三个产生冲突的xApp

